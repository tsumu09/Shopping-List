//
//  FirestoreManager.swift
//  Shopping List
//
//  Created by È´òÊ©ãÁ¥¨Â≠£ on 2025/07/09.
//

import Foundation
import FirebaseFirestore
import FirebaseAuth

final class FirestoreManager {
    static let shared = FirestoreManager()
    private let db = Firestore.firestore()
    
    private init() {}
    
    /// „É¶„Éº„Ç∂„ÉºÂ≠òÂú®Á¢∫Ë™ç
    public func userExists(uid: String, completion: @escaping (Bool) -> Void) {
        db.collection("users").document(uid).getDocument { snapshot, error in
            if let error = error {
                print("Error checking user existence: \(error.localizedDescription)")
                completion(false)
            } else {
                completion(snapshot?.exists == true)
            }
        }
    }
    
    /// „É¶„Éº„Ç∂„ÉºÁôªÈå≤
    public func insertUser(_ user: FirestoreUser, completion: @escaping (Bool) -> Void) {
        let safeEmail = user.emailAddress.lowercased()
            .replacingOccurrences(of: ".", with: "-")
            .replacingOccurrences(of: "@", with: "-")

        db.collection("users").document(safeEmail).setData([
            "first_name": user.firstName,
            "last_name": user.lastName,
            "email": user.emailAddress,   // „Ç™„É™„Ç∏„Éä„É´
            "raw_email": user.emailAddress
        ]) { error in
            if let error = error {
                print("Failed to insert user: \(error.localizedDescription)")
                completion(false)
            } else {
                print("User inserted successfully")
                completion(true)
            }
        }
    }
   
    static func safeEmail(_ email: String) -> String {
        return email.lowercased()
            .replacingOccurrences(of: ".", with: "-")
            .replacingOccurrences(of: "@", with: "-")
    }


    func makeSafeEmail(from email: String) -> String {
        return email.lowercased()
                    .replacingOccurrences(of: ".", with: "-")
                    .replacingOccurrences(of: "@", with: "-")
    }



    
    func addShop(to groupId: String, name: String, latitude: Double, longitude: Double, completion: @escaping (Error?) -> Void) {
            let shopRef = db
                .collection("groups").document(groupId)
                .collection("shops").document()
            let data: [String: Any] = [
                "name": name,
                "latitude": latitude,
                "longitude": longitude
            ]
            shopRef.setData(data) { error in
                completion(error)
            }
        }
    
    func addItem(to groupId: String,
                 shopId: String,
                 name: String,
                 price: Double,
                 importance: Int,
                 detail: String,
                 completion: @escaping (Result<String, Error>) -> Void) {
        let db = Firestore.firestore()
        let itemRef = db.collection("groups")
            .document(groupId)
            .collection("shops")
            .document(shopId)
            .collection("items")
            .document()

        let itemData: [String: Any] = [
            "name": name,
            "price": price,
            "isChecked": false,
            "importance": importance,
            "detail": detail,
            "deadline": NSNull(),
            "requestedBy": Auth.auth().currentUser?.displayName ?? "Ë™∞„Åã",
            "createdAt": Timestamp(date: Date()),
            "buyerIds": [], // ÂàùÊúüÂÄ§„ÅØÁ©∫
            "purchaseIntervals": [], // ÂàùÊúüÂÄ§„ÅØÁ©∫
            "averageInterval": NSNull() // „Åæ„Å†Ë®àÁÆó„Åß„Åç„Å™„ÅÑ„Åã„Çâ null
        ]

        itemRef.setData(itemData) { error in
            if let error = error {
                completion(.failure(error))
            } else {
                completion(.success(itemRef.documentID))
            }
        }

        // ÈÄöÁü•„ÇíËøΩÂä†
        db.collection("groups")
          .document(groupId)
          .collection("notifications")
          .addDocument(data: [
            "message": "\(Auth.auth().currentUser?.displayName ?? "Ë™∞„Åã")„ÅåÂïÜÂìÅ„Äå\(name)„Äç„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü",
            "timestamp": Timestamp(date: Date())
          ])
    }






    

    func updateItem(groupId: String, shop: Shop, item: Item, completion: ((Error?) -> Void)? = nil) {
        guard !item.id.isEmpty else {
            print("Error: item.id „ÅåÁ©∫„Åß„Åô„ÄÇFirestoreÊõ¥Êñ∞„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ")
            completion?(NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "item.id is empty"]))
            return
        }

        let docRef = db.collection("groups").document(groupId)
                       .collection("shops").document(shop.id)
                       .collection("items").document(item.id)

        var updatedItem = item
        let now = Date()

        // üîπË≥ºÂÖ•Êó•Â±•Ê≠¥„ÇíÊõ¥Êñ∞
        var history = updatedItem.purchaseHistory
        history.append(now)
        updatedItem.purchaseHistory = history

        // üîπË≥ºÂÖ•ÈñìÈöî„ÇíË®àÁÆóÔºà2Âõû‰ª•‰∏äË≥ºÂÖ•„Åó„Å¶„ÅÑ„Åü„ÇâÔºâ
        let dates = updatedItem.purchaseHistory.sorted()
        if dates.count >= 2 {
            var intervals: [Double] = []
            for i in 1..<dates.count {
                let interval = dates[i].timeIntervalSince(dates[i-1]) / (60 * 60 * 24) // Êó•Âçò‰Ωç
                intervals.append(interval)
            }
            let avg = intervals.reduce(0, +) / Double(intervals.count)
            updatedItem.averageInterval = (avg * 10).rounded() / 10 // Â∞èÊï∞Á¨¨1‰Ωç„Åæ„Åß
        }


        let data: [String: Any] = [
            "name": updatedItem.name,
            "price": updatedItem.price,
            "detail": updatedItem.detail,
            "deadline": updatedItem.deadline != nil ? Timestamp(date: updatedItem.deadline!) : FieldValue.serverTimestamp(),
            "importance": updatedItem.importance,
            "isChecked": updatedItem.isChecked,
            "buyerIds": updatedItem.buyerIds,
            "purchaseHistory": updatedItem.purchaseHistory,
            "purchaseIntervals": updatedItem.purchaseIntervals,
            "averageInterval": updatedItem.averageInterval ?? 0
        ]

        docRef.updateData(data) { error in
            if let error = error {
                print("Firestore Êõ¥Êñ∞„Ç®„É©„Éº: \(error.localizedDescription)")
            } else {
                print("Firestore Êõ¥Êñ∞ÊàêÂäü")
            }
            completion?(error)
        }
    }
    
    /// „Ç∞„É´„Éº„Éó‰ΩúÊàêÔºà„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Åß„Ç∞„É´„Éº„ÉóÊú¨‰ΩìÔºã„É°„É≥„Éê„ÉºÂàùÊúüËøΩÂä†Ôºâ
    func createGroup(name: String, completion: @escaping (Result<String, Error>) -> Void) {
        guard let uid = Auth.auth().currentUser?.uid else { return }
        let groupRef = db.collection("groups").document()
        let data: [String: Any] = [
            "name": name,
            "ownerId": uid
        ]
        
        db.runTransaction({ tx, _ in
            tx.setData(data, forDocument: groupRef)
            tx.setData([
                "joinedAt": Timestamp(),
                "displayName": Auth.auth().currentUser?.displayName ?? ""
            ], forDocument: groupRef.collection("members").document(uid))
            return nil
        }) { _, error in
            if let e = error {
                completion(.failure(e))
            } else {
                
                let shopRef = groupRef.collection("shops").document()
                            let shopData: [String: Any] = [
                                "name": "ÊúÄÂàù„ÅÆ„ÅäÂ∫ó",
                                "latitude": 0.0,
                                "longitude": 0.0,
                                "createdAt": Timestamp()
                            ]
                            shopRef.setData(shopData) { shopError in
                                if let shopError = shopError {
                                    print("ÂàùÊúü„Ç∑„Éß„ÉÉ„ÉóËøΩÂä†Â§±Êïó: \(shopError.localizedDescription)")
                                } else {
                                    print("ÂàùÊúü„Ç∑„Éß„ÉÉ„ÉóËøΩÂä†ÊàêÂäü")
                                }
                            }
                completion(.success(groupRef.documentID))
            }
        }
    }

    func fetchItem(shopId: String, itemId: String, completion: @escaping (Item?) -> Void) {
            guard let groupId = SessionManager.shared.groupId else {
                completion(nil)
                return
            }

            db.collection("groups")
                .document(groupId)
                .collection("shops")
                .document(shopId)
                .collection("items")
                .document(itemId)
                .getDocument { snapshot, error in
                    if let error = error {
                        print("„Ç¢„Ç§„ÉÜ„É†ÂèñÂæóÂ§±Êïó: \(error)")
                        completion(nil)
                        return
                    }

                    guard let data = snapshot?.data() else {
                        completion(nil)
                        return
                    }

                    // Item „Çí Firestore „Éá„Éº„Çø„Åã„ÇâÁîüÊàê
                    let item = Item.fromDictionary(data, id: itemId)
                    completion(item)
                }
        }
    
    func observeShops(in groupId: String,
                          onUpdate: @escaping ([Shop]) -> Void) -> ListenerRegistration {
            let shopsRef = db
                .collection("groups").document(groupId)
                .collection("shops")
            return shopsRef.addSnapshotListener { snap, _ in
                guard let docs = snap?.documents else { return }
                var shops: [Shop] = []
                let dg = DispatchGroup()
                
                for d in docs {
                    // „Éï„Ç£„Éº„É´„Éâ„Åã„Çâ‰ΩçÁΩÆÊÉÖÂ†±„ÇíÂèñÂæó
                    let lat = d["latitude"] as? Double ?? 0
                    let lng = d["longitude"] as? Double ?? 0
                    
                    // Á©∫„ÅÆ items „ÅßÂàùÊúüÂåñ
                    var shop = Shop(
                        id: d.documentID,
                        name: d["name"] as? String ?? "",
                        latitude: lat,
                        longitude: lng,
                        items: []
                    )
                    
                    dg.enter()
                    self.db
                        .collection("groups").document(groupId)
                        .collection("shops").document(d.documentID)
                        .collection("items")
                        .order(by: "importance", descending: true)
                        .getDocuments { itemsSnap, _ in
                            shop.items = itemsSnap?.documents.compactMap { i in
                                Item(
                                    id: i.documentID,
                                    name: i["name"] as? String ?? "",
                                    price: i["price"] as? Double ?? 0,
                                    isChecked: i["isChecked"] as? Bool ?? false,
                                    importance: i["importance"] as? Int ?? 0,
                                    detail: i["detail"] as? String ?? "",
                                    deadline: i["deadline"] as? Date ?? Date(),
                                    requestedBy: i["requestedBy"] as? String ?? "",
                                    buyerIds: i["buyerIds"] as? [String] ?? [],  // ‚ÜêËøΩÂä†
                                    purchaseIntervals: i["purchaseIntervals"] as? [Int] ?? [],
                                    averageInterval: i["averageInterval"] as? Double ?? 0.0
                                )
                            } ?? []
                            shops.append(shop)
                            dg.leave()
                        }
                }
                
                dg.notify(queue: .main) {
                    onUpdate(shops)
                }
            }
        }
    
    func observeItems(in groupId: String, shopId: String, onUpdate: @escaping ([Item]) -> Void) -> ListenerRegistration {
        let itemsRef = db
            .collection("groups").document(groupId)
            .collection("shops").document(shopId)
            .collection("items")
            .order(by: "importance", descending: true)  // ‰∏¶„Å≥È†Ü„ÇÇÊåáÂÆö„Åß„Åç„Çã

        return itemsRef.addSnapshotListener { snapshot, error in
            guard let docs = snapshot?.documents else {
                print("items„ÅÆÂèñÂæóÂ§±Êïó or „Å™„Åó")
                onUpdate([])
                return
            }

            let items = docs.compactMap { d -> Item? in
                return Item(
                    id: d.documentID,
                    name: d["name"] as? String ?? "",
                    price: Double(Int(d["price"] as? Double ?? 0)),
                    isChecked: d["isChecked"] as? Bool ?? false,
                    importance: d["importance"] as? Int ?? 0,
                    detail: d["detail"] as? String ?? "",
                    deadline: (d["deadline"] as? Timestamp)?.dateValue() ?? Date(),
                    requestedBy: d["requestedBy"] as? String ?? "",
                    purchaseIntervals: d["purchaseIntervals"] as? [Int] ?? [],
                    averageInterval: d["averageInterval"] as? Double ?? 0.0
                )
            }
            onUpdate(items)
        }
    }

    
    // MARK: „É©„É≥„ÉÄ„É†Ëã±Êï∞Â≠ó„Ç≥„Éº„Éâ„ÇíÁîüÊàê„Åó„ÄÅgroup/{groupId}/invites/{code} „Éâ„Ç≠„É•„É°„É≥„Éà„Å´
        // expiresAt (ÊúâÂäπÊúüÈôê) „Çí„Çª„ÉÉ„Éà„Åô„Çã
        func generateInviteCode(
            for groupId: String,
            validFor minutes: Int = 10,
            completion: @escaping (Result<String, Error>) -> Void
        ) {
            let code = randomString(length: 6)
            let expiresAt = Timestamp(date: Date().addingTimeInterval(TimeInterval(minutes * 60)))
            let inviteRef = db.collection("invites").document(code)
            let data: [String: Any] = [
                "groupId": groupId,
                "expiresAt": expiresAt
            ]
            inviteRef.setData(data) { error in
                if let e = error { completion(.failure(e)) }
                else           { completion(.success(code)) }
            }
        }
        
        
        // Ëã±Êï∞Â≠ó„É©„É≥„ÉÄ„É†ÁîüÊàê„Éò„É´„Éë„Éº
        private func randomString(length: Int) -> String {
            let chars = Array("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
            return String((0..<length).map { _ in chars.randomElement()! })
        }
        
        // MARK: ‚Äî „Ç∞„É´„Éº„ÉóÂèÇÂä†
        func joinGroup(groupId: String, completion: @escaping (Error?) -> Void) {
            guard let uid = Auth.auth().currentUser?.uid else { return }
            let memberRef = db
                .collection("groups").document(groupId)
                .collection("members").document(uid)
            memberRef.setData(["joinedAt": Timestamp(), "displayName": Auth.auth().currentUser?.displayName ?? ""]) { error in
                completion(error)
            }
        }
        
    // MARK: ÊãõÂæÖ„Ç≥„Éº„Éâ„Åã„Çâ groupId „ÇíÊé¢„Åó„Å¶ÂèÇÂä†„Éª„É¶„Éº„Ç∂„Éº„Éâ„Ç≠„É•„É°„É≥„Éà„ÇÇÊõ¥Êñ∞„Åô„Çã
    func joinGroup(withInviteCode code: String,
                   completion: @escaping (Result<String, Error>) -> Void) {

        let ref = db.collection("invites").document(code)
        ref.getDocument { snap, error in
            if let e = error { return completion(.failure(e)) }
            guard let data = snap?.data(),
                  let groupId = data["groupId"] as? String,
                  let expiresAt = data["expiresAt"] as? Timestamp else {
                return completion(.failure(
                    NSError(domain:"", code:0,
                            userInfo:[NSLocalizedDescriptionKey:"ÁÑ°Âäπ„Å™ÊãõÂæÖ„Ç≥„Éº„Éâ„Åß„Åô"])
                ))
            }

            // ÊúüÈôê„ÉÅ„Çß„ÉÉ„ÇØ
            if expiresAt.dateValue() < Date() {
                return completion(.failure(
                    NSError(domain:"", code:0,
                            userInfo:[NSLocalizedDescriptionKey:"„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØÊúüÈôêÂàá„Çå„Åß„Åô"])
                ))
            }

            guard let email = Auth.auth().currentUser?.email else {
                return completion(.failure(
                    NSError(domain:"", code:0,
                            userInfo:[NSLocalizedDescriptionKey:"„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì"])
                ))
            }

            let safeEmail = email.replacingOccurrences(of: ".", with: "-")
                                 .replacingOccurrences(of: "@", with: "-")

            let userDocRef = self.db.collection("users").document(safeEmail)
            userDocRef.getDocument { snapshot, error in
                guard let userData = snapshot?.data(),
                      let firstName = userData["first_name"] as? String else {
                    return completion(.failure(
                        NSError(domain:"", code:0,
                                userInfo:[NSLocalizedDescriptionKey:"„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±ÂèñÂæóÂ§±Êïó"])
                    ))
                }

                // üîπ pendingMembers „Å´ËøΩÂä†„Åô„Çã
                let pendingRef = self.db.collection("groups")
                                        .document(groupId)
                                        .collection("pendingMembers")
                                        .document(safeEmail)

                pendingRef.setData([
                    "joinedAt": Timestamp(),
                    "displayName": firstName,
                    "userDocId": safeEmail
                ]) { error in
                    if let error = error {
                        completion(.failure(error))
                    } else {
                        // üîπ users „Éâ„Ç≠„É•„É°„É≥„Éà„Å´ groupId „Çí merge
                        userDocRef.setData(["groupId": groupId], merge: true) { _ in
                            completion(.success(groupId))
                        }
                    }
                }
            }
        }
    }



    func fetchItems(groupId: String, shop: Shop, completion: @escaping ([Item]) -> Void) {
            let db = Firestore.firestore()
            db.collection("groups")
                .document(groupId)
                .collection("shops")
                .document(shop.id)
                .collection("items")
                .getDocuments { snapshot, error in
                    if let error = error {
                        print("ÂïÜÂìÅÂèñÂæóÂ§±Êïó: \(error.localizedDescription)")
                        completion([])
                        return
                    }

                    var items: [Item] = []
                    snapshot?.documents.forEach { doc in
                        if let item = try? doc.data(as: Item.self) {
                            items.append(item)
                        }
                    }

                    completion(items)
                }
        }
    
    func checkItem(_ item: Item, in shop: Shop) {
        guard let groupId = SessionManager.shared.groupId else { return }
        let db = Firestore.firestore()
        
        // Item Êõ¥Êñ∞
        db.collection("groups")
          .document(groupId)
          .collection("shops")
          .document(shop.id)
          .collection("items")
          .document(item.id)
          .updateData([
            "isChecked": true,
            "purchasedDate": Timestamp(date: Date()),
            "buyerIds": FieldValue.arrayUnion([Auth.auth().currentUser?.uid ?? ""])
          ])
        
        // ÈÄöÁü•„ÇíËøΩÂä†
        db.collection("groups")
          .document(groupId)
          .collection("notifications")
          .addDocument(data: [
            "message": "\(Auth.auth().currentUser?.displayName ?? "Ë™∞„Åã")„Åå\(item.name)„ÇíË≥ºÂÖ•„Åó„Åæ„Åó„Åü",
            "timestamp": Timestamp(date: Date())
          ])
    }


    
}

// „É¶„Éº„Ç∂„Éº„É¢„Éá„É´
struct FirestoreUser {
    let firstName: String
    let lastName: String
    let emailAddress: String
    var safeEmail: String {
        FirestoreManager.shared.makeSafeEmail(from: emailAddress)
    }

}

extension FirestoreManager {
    func fetchUserNames(completion: @escaping ([String: String]) -> Void) {
        db.collection("users").getDocuments { snapshot, error in
            var names: [String: String] = [:]
            if let docs = snapshot?.documents {
                for doc in docs {
                    let data = doc.data()
                    let displayName = (data["first_name"] as? String ?? "") + " " + (data["last_name"] as? String ?? "")
                    names[doc.documentID] = displayName
                }
            }
            completion(names)
        }
    }
   
        /// pendingMembers „ÅÆÊâøË™çÂá¶ÁêÜ
    func approveMember(safeEmail: String, groupId: String, completion: @escaping (Error?) -> Void) {
            let pendingRef = db.collection("groups")
                               .document(groupId)
                               .collection("pendingMembers")
                               .document(safeEmail)
            
            let memberRef = db.collection("groups")
                              .document(groupId)
                              .collection("members")
                              .document(safeEmail)
            
            // pending „Åã„Çâ„Éá„Éº„ÇøÂèñÂæó
            pendingRef.getDocument { snapshot, error in
                if let error = error {
                    completion(error)
                    return
                }
                guard let data = snapshot?.data() else {
                    completion(NSError(domain: "", code: 0, userInfo: [NSLocalizedDescriptionKey: "pending „É°„É≥„Éê„Éº„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì"]))
                    return
                }
                
                // members „Å´ËøΩÂä†
                memberRef.setData(data) { error in
                    if let error = error {
                        completion(error)
                        return
                    }
                    
                    // pending „Åã„ÇâÂâäÈô§
                    pendingRef.delete { error in
                        completion(error) // ÊàêÂäü„Å™„Çâ error = nil
                    }
                }
            }
        }
    }
